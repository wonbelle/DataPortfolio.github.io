<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ë¹„íŠ¸ì½”ì¸ ìë™ë§¤ë§¤ ì½”ë“œ</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    pre {
      background: #f4f4f4;
      padding: 1em;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>
</head>
<body>
  <header>
    <h1>ğŸ“œ ë¹„íŠ¸ì½”ì¸ ìë™ë§¤ë§¤ ì „ì²´ ì½”ë“œ</h1>
  </header>

  <section>
    <pre><code>
        ë¹„íŠ¸ ì½”ì¸ ìë™ ë§¤ë§¤ í…ŒìŠ¤íŠ¸ ì½”ë“œ

        import requests
        import jwt
        import uuid
        import hashlib
        import time
        import pandas as pd
        import numpy as np
        from urllib.parse import urlencode
        import ta  # ê¸°ìˆ ì  ë¶„ì„ ë¼ì´ë¸ŒëŸ¬ë¦¬
        from IPython.display import clear_output  
        import random
        
        # ì—…ë¹„íŠ¸ API í‚¤ ì„¤ì • (í™˜ê²½ ë³€ìˆ˜ ì‚¬ìš© ê°€ëŠ¥)
        access_key = 'ë³¸ì¸ì˜ access_key ë„£ìœ¼ì‹œë©´ ë©ë‹ˆë‹¤'
        secret_key = 'ë³¸ì¸ì˜ secret_key ë„£ìœ¼ì‹œë©´ ë©ë‹ˆë‹¤'
        server_url = 'https://api.upbit.com'
        
        # ì„¤ì •ê°’ (ì†ì ˆ & ìµì ˆ ë¹„ìœ¨, ìš”ì²­ ê°„ê²©)
        TRADING_FEE = 0.0005  # 0.05% ê±°ë˜ ìˆ˜ìˆ˜ë£Œ
        STOP_PROFIT_RATIO = 0.04  # 4% ìµì ˆ
        STOP_LOSS_RATIO = 0.02  # 2% ì†ì ˆ
        REQUEST_INTERVAL = 2  # API ìš”ì²­ ê°„ê²© (ì´ˆ)
        RETRY_WAIT = 10  # 429 ì˜¤ë¥˜ ë°œìƒ ì‹œ ì¬ì‹œë„ ëŒ€ê¸° ì‹œê°„ (ì´ˆ)
        
        # API ìš”ì²­ì„ ìœ„í•œ í—¤ë” ìƒì„± í•¨ìˆ˜
        def get_headers(query=None):
            payload = {'access_key': access_key, 'nonce': str(uuid.uuid4())}
            if query:
                query_string = urlencode(query).encode()
                m = hashlib.sha512()
                m.update(query_string)
                query_hash = m.hexdigest()
                payload['query_hash'] = query_hash
                payload['query_hash_alg'] = 'SHA512'
            jwt_token = jwt.encode(payload, secret_key)
            headers = {'Authorization': f'Bearer {jwt_token}'}
            return headers
        
        # API ìš”ì²­ í•¨ìˆ˜ (429 ë°±ì˜¤í”„ ì ìš©)
        def safe_api_request(url, params=None):
            for attempt in range(5):
                try:
                    res = requests.get(url, headers={'accept': 'application/json'}, params=params, timeout=10)
                    if res.status_code == 429:
                        wait_time = RETRY_WAIT * (2 ** attempt) + random.uniform(0, 1)
                        print(f" API ìš”ì²­ ì œí•œ (429): {wait_time:.1f}ì´ˆ í›„ ì¬ì‹œë„...")
                        time.sleep(wait_time)
                        continue
                    res.raise_for_status()
                    return res.json()
                except Exception as e:
                    print(f" API ìš”ì²­ ì‹¤íŒ¨: {e}")
                    time.sleep(RETRY_WAIT)
            return None
        
        # ì‹¤ì‹œê°„ ê°€ê²© ê°€ì ¸ì˜¤ê¸°
        def get_current_price(market):
            url = f"{server_url}/v1/ticker"
            data = safe_api_request(url, {"markets": market})
            return data[0]['trade_price'] if data else None
        
        # íŠ¹ì • ì½”ì¸ì˜ ê³¼ê±° ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        def get_price_data(market, count=50):
            url = f"{server_url}/v1/candles/minutes/60"
            data = safe_api_request(url, {"market": market, "count": count})
            if not data:
                return None
            df = pd.DataFrame(data)
            df['candle_date_time_kst'] = pd.to_datetime(df['candle_date_time_kst'])
            df.set_index('candle_date_time_kst', inplace=True)
            return df[['high_price', 'low_price', 'trade_price', 'candle_acc_trade_volume']].rename(columns={'trade_price': 'close'})
        
        # ë§¤ìˆ˜ ëŒ€ìƒ ì°¾ê¸°
        def get_best_market():
            url = f"{server_url}/v1/market/all"
            headers = {'accept': 'application/json'}
            
            try:
                res = requests.get(url, headers=headers, timeout=10)
                res.raise_for_status()
                markets = [m['market'] for m in res.json() if m['market'].startswith(('KRW-', 'BTC-', 'USDT-'))]
                
                for market in markets[:150]:  
                    if analyze_chart(market):
                        print(f" ë§¤ìˆ˜ ëŒ€ìƒ ì½”ì¸ ë°œê²¬: {market}")
                        return market
                    time.sleep(REQUEST_INTERVAL)
                
                print(" ì ì ˆí•œ ë§¤ìˆ˜ ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤.")
                return None
            except Exception as e:
                print(f" ì‹œì¥ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: {e}")
                return None
        
        # ê¸°ìˆ ì  ë¶„ì„ (ë³¼ë¦°ì € ë°´ë“œ, ê±°ë˜ëŸ‰ ì¦ê°€ìœ¨ ì¶”ê°€)
        def analyze_chart(market):
            df = get_price_data(market, count=50)
            if df is None or df.empty:
                return False
        
            df['rsi'] = ta.momentum.RSIIndicator(df['close'], window=14).rsi()
            df['macd'] = ta.trend.MACD(df['close']).macd()
            df['macd_signal'] = ta.trend.MACD(df['close']).macd_signal()
            df['cci'] = ta.trend.CCIIndicator(df['high_price'], df['low_price'], df['close'], window=20).cci()
            df['bollinger_low'] = ta.volatility.BollingerBands(df['close']).bollinger_lband()
            df['volume_change'] = df['candle_acc_trade_volume'].pct_change()
            
            return (
                df['rsi'].iloc[-1] < 65 and
                df['macd'].iloc[-1] >= df['macd_signal'].iloc[-1] - 0.001 and
                df['cci'].iloc[-1] > -250 and
                df['volume_change'].iloc[-1] > 0.3 and
                df['close'].iloc[-1] < df['bollinger_low'].iloc[-1]
            )
        
        # ìë™ ë§¤ë§¤ ì‹¤í–‰ (ì‹¤ì œ ì‹œì¥ ë°ì´í„°ì—ì„œ ê±°ë˜ ì‹œë®¬ë ˆì´ì…˜)
        def simulated_trading(initial_balance=1000000):
            market = get_best_market()
            if market is None:
                print(" ì ì ˆí•œ ê±°ë˜ ì½”ì¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                return
            
            balance = initial_balance
            position = balance / get_current_price(market)
            entry_price = get_current_price(market)
            print(f" ê°€ìƒ ë§¤ìˆ˜ ì‹¤í–‰: {market} - {entry_price} ì›")
            
            while True:
                current_price = get_current_price(market)
                profit_ratio = (current_price - entry_price) / entry_price
                
                if profit_ratio >= STOP_PROFIT_RATIO or profit_ratio <= -STOP_LOSS_RATIO:
                    balance = position * current_price * (1 - TRADING_FEE)
                    print(f" ê°€ìƒ ë§¤ë„ ì‹¤í–‰: {market} - {current_price} ì›")
                    break
                
                clear_output(wait=True)
                print(f"í˜„ì¬ ì½”ì¸: {market} | í˜„ì¬ ê°€ê²©: {current_price} ì› | ìˆ˜ìµë¥ : {profit_ratio * 100:.2f}%")
                time.sleep(REQUEST_INTERVAL)
        
        # ì‹¤í–‰
        if __name__ == '__main__':
            simulated_trading()
        
        
    </code></pre>
  </section>

  <footer>
    <p><a href="bitcoin.html">â† ë¹„íŠ¸ì½”ì¸ í”„ë¡œì íŠ¸ë¡œ ëŒì•„ê°€ê¸°</a></p>
  </footer>
</body>
</html>